# -*- coding: utf-8 -*-
"""E2_PrecioOpcionEuropea

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TbMWbbZBZM0yK1yHpfb70rHNL2ECkHMw

<font face = "Times New Roman" size = "3" color = "black">
<center>
<h3></h3>
<img src = "https://proleon.com.mx/wp-content/uploads/2022/10/01_TM_ESPECIAL_INNOVACION_EDUCATIVA_UNIVERSIDADES_TEC_DE_MONTERREY.png" width = "250">
<h3><b>Campus Estado de México</h3>
<h3>Optimización Estocástica</b><br>MA2004B.201 2024-13<br><br><b>Evidencia 2. Cálculo del Precio de una Opción Europea<br><br>Autores</b><br>Daniel Makoszay Castañón - A01750046<br>Santiago Jiménez Pasillas - A01749970<br>Santiago Palavicini Saldívar - A01749103<br>Guillermo Ian Barbosa Martínez - A01747926<br><br><b>Profesores</b><br>Saúl Juárez Ordóñez<br>Pablo Mendoza Iturralde<br>Faustino Yescas Martínez</h3>
<img src = "https://i-invdn-com.investing.com/news/LYNXNPEE331YJ_L.jpg" width = "500">
<h6>Crédito de la imagen: <a href = "https://www.reporteindigo.com/reporte/calidad-del-aire-en-zona-metropolitana-entre-regular-y-mala/">Márgenes Verticales Elevados de <i>Spotify</i></a></h6>
</img>
</center>
</font>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Resumen</b></h2>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h4>Este reporte presenta el cálculo del precio de una opción europea sobre las acciones de Spotify, utilizando varias técnicas de modelado financiero y simulación, incluyendo las cadenas de Markov, el modelo de Black-Scholes, simulaciones Monte Carlo y el movimiento Browniano geométrico (GBM). Los datos históricos fueron preprocesados y se aplicaron métodos de suavización con ventanas deslizantes para mejorar la precisión de las predicciones. Se implementaron los modelos para predecir precios de cierre ajustados y estimar el valor de las opciones. Los resultados muestran que las ventanas deslizantes mejoraron la precisión de las predicciones, mientras que las simulaciones Monte Carlo y el GBM fueron eficaces para modelar trayectorias estocásticas de los precios.</h4>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b><i>Abstract<i></b></h2>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h4><i>This report presents the calculation of a European option price on Spotify stocks using various financial modeling and simulation techniques, including Markov chains, the Black-Scholes model, Monte Carlo simulations, and Geometric Brownian Motion (GBM). Historical data was preprocessed and sliding window methods were applied to enhance prediction accuracy. The models were implemented to forecast adjusted closing prices and estimate option values. The results show that sliding windows improved prediction accuracy, while Monte Carlo simulations and GBM were effective in modeling stochastic price paths.</i></h4>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Palabras clave</b> (<i>keywords</i>)</h2>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h4><i>Cadenas de Markov, Modelo de Black-Scholes, Simulación Monte Carlo, Movimiento Browniano Geométrico, Precio de opciones, Rendimientos logarítmicos, Ventanas deslizantes, Opciones europeas.</i></h4>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Correos electrónicos</b></h2><h4>Daniel Makoszay Castañón - a01750046@tec.mx<br>Santiago Jiménez Pasillas - a01749970@tec.mx<br>Santiago Palavicini Saldívar - a01749103@tec.mx<br>Guillermo Ian Barbosa Martínez - a01747926@tec.mx</h4>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Introducción</b></h2>
<h4>Las opciones financieras son derivados que otorgan al comprador el derecho, pero no la obligación, de comprar o vender un activo subyacente a un precio específico en una fecha futura. Este trabajo se enfoca en calcular el precio de una opción europea sobre las acciones de Spotify utilizando varios modelos de predicción financiera, como las cadenas de Markov, el modelo de Black-Scholes, simulaciones Monte Carlo y el movimiento Browniano geométrico (GBM). Cada uno de estos enfoques ofrece distintas ventajas para modelar la evolución estocástica de los precios en el tiempo y evaluar el valor de las opciones bajo diferentes escenarios. Este reporte explora la precisión y aplicabilidad de cada técnica en la predicción de precios de opciones.</h4>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Marco Conceptual</b></h2>
<h3><b>Conceptos Clave para Opciones Financieras</b></h3>
<h4>Una opción financiera es un contrato que otorga al comprador el derecho, pero no la obligación, de comprar o vender un activo subyacente a un precio específico (precio de ejercicio) en una fecha determinada. Los activos subyacentes pueden ser tangibles, como materias primas, o intangibles, como acciones y divisas. Existen opciones de compra (<i>call</i>) y de venta (<i>put</i>), con la diferencia entre opciones europeas y americanas siendo el momento en que se pueden ejercer: solo en la fecha de vencimiento para la europea, o en cualquier momento hasta el vencimiento para la americana (Chen, 2024).</h4>

<h4>La prima es el costo que paga el comprador por el derecho de la opción, y su valor depende de factores como la volatilidad del activo subyacente y el precio de ejercicio. La volatilidad refleja la incertidumbre del precio del activo y se mide como la desviación estándar de sus retornos. Si el precio de un activo en la fecha de vencimiento no favorece el ejercicio de la opción, el inversor puede optar por no ejercerla, resultando en la pérdida de la prima pagada (CFI).</h4>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Métodología utilizada</b></h2>
<h3><b>Pre-procesamiento</h3></b>
<h4>
El pre-procesamiento de los datos es una etapa fundamental para garantizar la calidad y la precisión en el análisis financiero realizado en este estudio. Inicialmente, se seleccionó el activo subyacente, en este caso, las acciones de <i>Spotify</i> (símbolo "SPOT"), y se obtuvieron los datos históricos de precios de cierre y tasas libres de riesgo (<i>IRX</i>) mediante la biblioteca <i>yfinance</i>, asegurando una cobertura temporal de un año (octubre 2023 a octubre 2024) y una cantidad mínima de 100 observaciones. Posteriormente, se realizó una limpieza de los datos para identificar y corregir posibles inconsistencias, como valores faltantes o atípicos, utilizando métodos estadísticos como el rango intercuartílico (<i>IQR</i>) para la detección de outliers. Se calcularon los rendimientos logarítmicos diarios a partir de los precios de cierre, lo que permite una mejor comparación y modelado de las variaciones porcentuales continuas en los precios (Shadmehr, 2023). Además, se aplicaron técnicas de descomposición estacional y medias móviles para suavizar las series temporales y resaltar tendencias subyacentes. Finalmente, se realizó una prueba de normalidad (<i>Shapiro-Wilk</i>) para verificar la distribución de los rendimientos, asegurando la adecuación de los datos para los modelos de valoración seleccionados. Este riguroso proceso de pre-procesamiento asegura que los datos utilizados en los modelos de <i>Black</i>-<i>Scholes</i> y cadenas de Markov sean fiables y representativos del comportamiento real del mercado, mejorando así la exactitud de las estimaciones de precios de opciones.

</h4>
<br>

<h3><b>Cadenas de Markov</b></h3>
<h4>
Las cadenas de Márkov son procesos útiles para modelar sistemas que evolucionan
de manera estocástica (aleatoria) a lo largo del tiempo. Se basa en la propiedad de
Márkov que dice, que la probabilidad de moverse de un estado a otro depende
únicamente del estado actual, y no de los estados anteriores (cpfund, 2018).
<h4>
<p style="text-align: center;">
    <h5><i>P(X<sub>n+1</sub> = x | X<sub>1</sub> = x<sub>1</sub>, X<sub>2</sub> = x<sub>2</sub>, ..., X<sub>n</sub> = x<sub>n</sub>) = P(X<sub>n+1</sub> = x | X<sub>n</sub> = x<sub>n</sub>)</i></h5>
</p>
<h4>
La evolución de una cadena de Markov se describe mediante una matriz de
transición P, donde cada elemento Pij es la probabilidad de pasar del estado i al
estado j. Por ejemplo:
<h4>
<p style="text-align: center;">
    <h5><i>P = \begin{pmatrix}
    p_{11} & p_{12} & \cdots & p_{1k} \\
    p_{21} & p_{22} & \cdots & p_{2k} \\
    \vdots & \vdots & \ddots & \vdots \\
    p_{k1} & p_{k2} & \cdots & p_{kk}
    \end{pmatrix}
    </i></h5>
</p>
<h4>
Características principales de las cadenas de Márkov:
- Número finito de estados: El sistema tiene un conjunto finito de estados
posibles. Cada estado representa una condición o situación particular del
sistema (Carrillo,s.f).
- Transiciones: El sistema se mueve de un estado a otro, y cada transición tiene
una probabilidad asociada (Carrillo,s.f).
- Aplicaciones Versátiles; Las cadenas de Markov se aplican en campos como
economía, biología, informática, telecomunicaciones, y más, para modelar
procesos aleatorios como fluctuaciones en mercados, difusión de
enfermedades, navegación web (Carrillo,s.f).
</h4>
<h4>
Para nuestro proyecto, aplicamos una cadena de Markov con el objetivo de predecir
el precio de cierre ajustado de las acciones de Spotify. La metodología fue la
siguiente:

1. Datos históricos: Utilizamos datos históricos del precio de cierre ajustado de
Spotify durante un periodo de 5 años para entrenamiento y un año adicional
para prueba. Cada precio de cierre diario fue considerado un estado del
sistema.

2. Definición de los estados: Para definir los estados, utilizamos el cambio
porcentual diario del precio de cierre respecto al día anterior, y lo
clasificamos en tres estados basados en los cuantiles:
Estado 0 (baja): Si el cambio porcentual es menor que el cuantil bajo, se
clasifica como una baja del precio respecto al día anterior.
Estado 1 (se mantiene): Si el cambio porcentual se mantiene dentro de un
rango intermedio (entre el cuantil bajo y el cuantil alto), se clasifica como
estable.
Estado 2 (sube): Si el cambio porcentual es mayor que el cuantil alto, se
clasifica como una subida del precio.
De esta forma, cada día fue categorizado en uno de estos tres estados, lo que
nos permitió tratar el problema como una cadena de Markov con estados
discretos.
3. Matriz de transición: A partir de los datos de entrenamiento, construimos una
matriz de transición que modela las probabilidades de que el precio de cierre
pase de un estado a otro en un día siguiente. La probabilidad de moverse de
un rango de precios a otro en el día siguiente dependía únicamente del estado
actual (precio actual), cumpliendo con la propiedad de Markov.
4. Predicción: Utilizando la matriz de transición calculada, pudimos hacer
predicciones para el precio de cierre en los días siguientes durante el periodo
de prueba (1 año). La predicción a largo plazo se basa en las transiciones
diarias entre los diferentes estados, obteniendo una probabilidad para el
precio esperado de cierre ajustado.
5. Caminata Aleatoria: Se hace una caminata tanto para los datos reales como
para los predichos, utilizando los estados definidos en la cadena de Markov (0
para baja, 1 para estable y 2 para subida)
6. Resultados: El modelo nos permitió observar patrones en el comportamiento
del precio y generar estimaciones razonables del precio de cierre ajustado
para el futuro cercano, dentro del periodo de prueba. La cadena de Markov capturó de manera efectiva las transiciones probables entre los rangos de
precios de día a día.

</h4><br>

<h3><b><i>Sliding Windows</i></b></h3>
<h4>
Las ventanas deslizantes son una técnica ampliamente utilizada en el análisis de series temporales y estadística que permite estudiar subconjuntos de los datos a medida que se deslizan a lo largo del tiempo (Kara, 2023). Son particularmente útiles para suavizar las gráficas con muchas variaciones en el tiempo, ayuda a eliminar el "ruido" a corto plazo, facilitando la identificación de tendencias subyacentes. La idea principal es aplicar la suma, su mínimo, máximo, promedio, etc. dentro de una ventana de tiempo definida y luego mover esa ventana a través de los datos (New Relic, 2024). De esta forma, se logran conservar patrones locales con respecto a su tiempo.<br><br>En este reto, se utilizaron las ventanas deslizantes combinadas con las cadenas de Markov para realizar el entrenamiento y predicción de los precios de cierre en las acciones de Spotify, teniendo un balance entre capturar las fluctuaciones y mejorar su precisión. Para esto, escoger el tamaño óptimo de la ventana fue una parte crucial del análisis. Al elegir una ventana más pequeña, se capturan cambios rápidos en el tiempo y la precisión no mostraba una mejora significativa. Por otro lado, las ventanas más grandes tienden a suavizar las variaciones, esencialmente perdiendo gran parte de la información, solo manteniendo la tendencia de los datos.
</h4><br>

<h3><b>Simulación con Movimiento <i>Browniano</i> Geométrico</b></h3>
<h4>
El movimiento <i>Browniano</i> geométrico (GBM) es un modelo matemático utilizado para simular el comportamiento aleatorio de precios de activos subyacentes, como acciones de <i>Spotify</i>, en series de tiempo. Este método asume que los cambios de precio son lognormalmente distribuidos y siguen un proceso estocástico continuo, donde la variación del precio de un activo depende de su precio actual, una tendencia de crecimiento constante (<i>drift</i>) y un componente aleatorio proporcional a la volatilidad del activo. Para la simulación de precios de cierre de acciones de <i>Spotify</i> en el mercado de valores, el GBM proporciona una base para estimar los posibles caminos futuros de los precios al integrar las tendencias deterministas y la incertidumbre inherente a los mercados financieros ().<br><br>El GBM sigue la siguiente ecuación diferencial:
<center>
<p style="text-align: center;">
    <h5><i>dS<sub>t</sub></i> = <i>μS<sub>t</sub>dt + σS<sub>t</sub>dW<sub>t</sub></i></h5>
    <h5><i>S<sub>t</sub></i> = <i>S<sub>0</sub>e<sup>(μ - (σ<sup>2</sup> / 2))t + σW<sub>t</sub></sup></i></h5>
</p>
</center>
donde:
<p style="text-align: center;">
<ul>
  <i><li><b>S<sub>t</sub></b></i> : Precio del activo subyacente en el tiempo <i>t</i>.</li>
  <i><li><b>dS<sub>t</sub></b></i> : Cambio en el precio del activo subyacente en un intervalo de tiempo infinitesimal.</li>
  <i><li><b>&mu;</b></i> : Tasa de crecimiento promedio (<i>drift</i>) del activo subyacente.</li>
  <i><li><b>&sigma;</b></i> : Volatilidad del activo subyacente.</li>
  <i><li><b>dW<sub>t</sub></b></i> : Incremento en el proceso de <i>Wiener</i> (componente aleatorio) en el tiempo <i>t</i>.</li>
</ul>
</p>
<br>El uso del movimiento <i>Browniano</i> geométrico en simulaciones permite modelar el comportamiento incierto del mercado, proporcionando escenarios de evolución de precios para la evaluación de riesgos y el cálculo de precios de opciones. A través de la combinación de <i>drift</i> y volatilidad, se logra capturar tanto la tendencia esperada del precio como la variabilidad inherente, lo cual es fundamental para la valoración precisa de activos subyacentes.<br><br>
</h4>

<h3><b>Modelo de Black-Scholes</b></h3>
<h4>El modelo de <i>Black-Scholes</i> es una fórmula matemática utilizada para calcular el precio de opciones europeas (<i>call</i> y <i>put</i>). El modelo asume que los precios de los activos siguen un movimiento <i>browniano</i> geométrico y que el mercado es eficiente, sin costos de transacción. Las variables clave incluyen el precio actual del activo subyacente, el precio de ejercicio, la volatilidad, la tasa de interés libre de riesgo, y el tiempo hasta el vencimiento. Este modelo permite determinar el valor justo de una opción con base en estas variables (López, 2020).<br><br>Las suposiciones del modelo incluyen: mercados sin arbitraje, tasas de interés constantes y conocidas, precios de activos que siguen una distribución log-normal, y que las opciones europeas solo se ejercen en la fecha de vencimiento. Sin embargo, estas suposiciones también limitan el modelo, ya que no considera eventos imprevistos, cambios en la volatilidad o intereses variables. Por lo tanto, aunque el modelo es ampliamente utilizado, tiene limitaciones en escenarios con alta volatilidad o mercados ineficientes (Hayes, 2024).<br><br>En la fórmula de <i>Black-Scholes</i>, la volatilidad implícita refleja la expectativa de la volatilidad futura del activo subyacente, estimada a partir del precio de mercado de la opción. El factor exponencial <i>e<sup>-rT</sub></i> representa el descuento del valor presente del precio de ejercicio, ajustando por la tasa de interés libre de riesgo <i>r</i> y el tiempo <i>T</i> hasta el vencimiento (Piñeira).<br>
<center>
<p style="text-align: center;">
<b>Ecuaciones de <i>Black-Scholes</i> para opciones:</b>
    <h5><b><i>Call</i></b> : <i>C</i> = <i>S<sub>0</sub>N</i>(<i>d<sub>1</i></sub>) - <i>Ke<sup>-rT</sup>N</i>(<i>d<sub>2</sub></i>)</h5>
    <h5><b><i>Put</i></b> : <i>P</i> = <i>Ke<sup>-rT</sup>N</i>(-<i>d<sub>2</sub></i>) - <i>S<sub>0</sub>N</i>(-<i>d<sub>1</sub></i>)</h5>
</p>
</center>
con:
<center>
<p style="text-align: center;">
  <h5><i>d<sub>1</sub></i> = (ln(<i>S<sub>0</sub></i> / <i>K</i>) + (<i>r</i> + <i>σ<sup>2</sup></i> / 2) <i>T</i>) / (<i>σ</i> √ <i>T</i>)</h5>
  <h5><i>d<sub>2</sub></i> = <i>d<sub>1</sub></i> - <i>σ</i> √ <i>T</i></h5>
</p>
</center>
donde:
<p style="text-align: center;">
<ul>
    <li><b><i>C</i></b> : Precio de la opción de compra (<i>call</i>).</li>
    <li><b><i>P</i></b> : Precio de la opción de venta (<i>put</i>).</li>
    <li><b><i>S</i><sub>0</sub></b> : Precio actual del activo subyacente.</li>
    <li><b><i>K</i></b> : Precio de ejercicio de la opción.</li>
    <li><b><i>r</i></b> : Tasa de interés libre de riesgo.</li>
    <li><b><i>T</i></b> : Tiempo hasta la fecha de vencimiento de la opción (en años).</li>
    <li><b><i>σ</i></b> : Volatilidad del activo subyacente.</li>
    <li><b><i>N</i>(<i>d</i>)</b> : Función de distribución acumulativa de una variable normal estándar.</li>
    <li><b><i>e<sup>-rT</sup></i></b> : Factor de descuento que representa el valor presente del precio de ejercicio.</li>
    <li><b><i>d<sub>1</sub></b></i> : Parámetro que mide la distancia en desviaciones estándar del precio actual al precio de ejercicio, ajustado por la tasa de interés y volatilidad.</li>
    <li><b><i>d<sub>2</sub></b></i> : Parámetro relacionado con <i>d<sub>1</sub></i> pero ajustado por la volatilidad durante el tiempo restante hasta el vencimiento.</li>
</ul>
</p>
<br>
</h4>

<h3><b>Simulación Monte Carlo</b></h3>
<h4>
La simulación de Monte Carlo es un método poderoso utilizado en finanzas para estimar el precio de opciones y otros derivados financieros mediante la creación de una serie de simulaciones aleatorias del comportamiento del precio de un activo subyacente. En el contexto de predecir el precio de cierre de una opción de compra para <i>Spotify</i>, este enfoque implica la generación de múltiples trayectorias posibles del precio del activo, tomando en cuenta la volatilidad y las tendencias históricas. Al calcular el valor esperado de los resultados de estas simulaciones, se puede estimar el precio de la opción en la fecha de madurez del contrato, proporcionando así una herramienta valiosa para los inversores en la toma de decisiones informadas (AWS).<br><br>
La simulación de Monte Carlo es una técnica poderosa para la valoración de derivados financieros, como opciones de compra, mediante la generación de múltiples trayectorias simuladas del precio del activo subyacente bajo un modelo probabilístico. Para estimar el precio de una opción de compra de Spotify, se simulan trayectorias del precio del activo con el proceso de Movimiento <i>Browniano</i> Geométrico (GBM), considerando la volatilidad histórica y una tasa de interés libre de riesgo. La metodología de valoración bajo el enfoque de precios neutrales al riesgo implica calcular el promedio de múltiples pagos descontados de la opción en la madurez, utilizando la fórmula del precio neutral al riesgo en tiempo continuo para aproximar el valor esperado del precio futuro. El código, basado en el repositorio de <i>The QuantPy</i> (2022), incluido implementa esta simulación con dos métodos: una solución iterativa y otra vectorizada más eficiente, donde se precomputan constantes, se generan distribuciones normales aleatorias para simular cambios en los precios y se calcula la media de los pagos descontados para estimar el valor de la opción.<br><br>
A continuación, se presentan las fórmulas utilizadas en el algoritmo:
<center>
<p style="text-align: center;">
    <h5><i>dS<sub>t</sub></i> = <i>μS<sub>t</sub>dt + σS<sub>t</sub>dW<sub>t</sub></i></h5>
</p>
</center>
donde:
<ul>
  <i><li><b>S<sub>t</sub></b></i> : Precio del activo subyacente en el tiempo <i>t</i>.</li>
  <i><li><b>dS<sub>t</sub></b></i> : Cambio en el precio del activo subyacente en un intervalo de tiempo infinitesimal.</li>
  <i><li><b>&mu;</b></i> : Tasa de crecimiento promedio (<i>drift</i>) del activo subyacente.</li>
  <i><li><b>&sigma;</b></i> : Volatilidad del activo subyacente.</li>
  <i><li><b>dW<sub>t</sub></b></i> : Incremento en el proceso de <i>Wiener</i> (componente aleatorio) en el tiempo <i>t</i>.</li>
</ul>

<br>

<center>
<p style="text-align: center;">
    <h5><i>dS<sub>t</sub> = (<i>μ</i> - 0.5<i>σ</i><sup>2</sup>)dt + <i>σ</i>√(dt)<i>Z</i></h5>
</p>
</center></i>
donde:
<ul>
  <i><li><b>&mu;</b></i> : Tasa de crecimiento esperada del activo.</li></i>
  <i><li><b>&sigma;</b></i> : Volatilidad del activo.</li></i>
  <i><li><b>Z</b></i> : Variable aleatoria que sigue una distribución normal estándar (N(0, <i>Δt</i>)).</li></i>
</ul>

<br>

<center>
<p style="text-align: center;">
    <h5><i>S<sub>t</sub> = S<sub>0</sub>e<sup>ΣdS<sub>t</sub></sub></i></h5>
</p>
</center>
donde:
<ul>
  <i><li><b>S<sub>0</sub></b></i> : Precio inicial del activo.</li></i>
  <i><li><b>ΣdS<sub>t</sub></b></i> : Suma acumulativa de los cambios en el logaritmo de los precios a lo largo del tiempo.</li></i>
</ul>

<br>

<p>Parámetros de la Simulación:</p>
<ul>
  <i><li><b>nsteps</b></i> : Número total de pasos de la simulación.</li></i>
  <i><li><b>t</b></i> : Tiempo total de la simulación (generalmente en años).</li></i>
  <i><li><b>&mu;</b></i> : Tasa ajustada de crecimiento esperada.</li></i>
  <i><li><b>&sigma;</b></i> : Volatilidad ajustada del activo.</li></i>
  <i><li><b>start</b></i> : Precio inicial del activo en la simulación.</li></i>
</ul>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Librerías y dependencias necesarias</b></h2>
"""

# Importa Yahoo Finance y Pandas para descargar y manipular datos financieros.
import yfinance as yf
import pandas as pd

# Importa bibliotecas de Plotly para crear gráficos interactivos y visualizaciones avanzadas.
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

# Instala y configura Chart Studio para publicar gráficos en línea.
!pip install chart_studio
from chart_studio import plotly
from chart_studio import grid_objs
import chart_studio.plotly as py

# Configura el modo de trabajo de Plotly para trabajar en cuadernos interactivos.
from plotly.offline import init_notebook_mode, iplot
init_notebook_mode(connected=True)

# Herramientas adicionales para visualizaciones personalizadas con Plotly.
from plotly import tools
import plotly.figure_factory as ff

# Bibliotecas para análisis estadístico, como modelado, distribución normal, y gráficos de autocorrelación.
import statsmodels.api as sm
from scipy.stats import norm
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# Configura Plotly para que renderice visualizaciones en Google Colab.
import plotly.io as pio
pio.renderers.default = 'colab'

# Bibliotecas para cálculos matemáticos y estadísticos.
import scipy.stats as st
import numpy as np
import math

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Datos de Spotify</b></h2>
"""

spot_info = yf.Ticker("SPOT")
# Datos de Oct-2023 a Oct-2024
df = spot_info.history(period="1Y")
df

# Información de los datos de Spotify
df.info()

# Estadística descriptiva de los datos de Spotify
df.describe().T

# Creamos la figura para visualizar la evolución los precios de cierre de acciones de Spotify
fig = go.Figure()

# Agregamos la línea de dispersión
fig.add_trace(go.Scatter(x=df.index, y=df['Close'], mode='lines', name='Close Price', line=dict(color='lightseagreen')))

fig.update_layout(
    title={
        'text': '<b>Precios de Cierre de Spotify (Oct2023 - Oct2024)</b>',
        'y': 0.9,
        'x': 0.5,
        'xanchor': 'center',
        'yanchor': 'top',
    },
    xaxis_title='Fecha',
    yaxis_title='Precio de Cierre',
    template='plotly_dark',
    xaxis=dict(title_font=dict(color='white'),),
    yaxis=dict(title_font=dict(color='white'),)
)

fig.show()

# Gráfico OHLC de Spotify
ohlc_spot = go.Ohlc(x=df.index, open=df.Open, high=df.High, low=df.Low, close=df.Close, name='Spotify OHLC')
fig_spot = go.Figure(data=[ohlc_spot])
fig_spot.update_layout(
    title={
        'text': '<b>Gráfico OHLC de Precios en el Mercado de Valores de Spotify</b>',
        'x': 0.5,
        'xanchor': 'center'
    }, yaxis_title='Spotify Prices',  xaxis_title='Fecha', template='plotly_dark')
fig_spot.show()

# Candlestick de Spotify
candle_spot = go.Candlestick(x=df.index, open=df.Open, high=df.High, low=df.Low, close=df.Close, name='Spotify Candlestick')
fig_spot2 = go.Figure(data=[candle_spot])
fig_spot2.update_layout(
    title={
        'text': '<b>Gráfico de Velas de Precios en el Mercado de Valores de Spotify</b>',
        'x': 0.5,
        'xanchor': 'center'
    }, yaxis_title='Spotify Prices',  xaxis_title='Fecha', template='plotly_dark'
)
fig_spot2.show()

# Descomposición estacional de los datos de cierre de Spotify con una frecuencia semanal.
decomposed_spot = sm.tsa.seasonal_decompose(df['Close'], period=7)

# Crear un DataFrame para cada componente de la descomposición: tendencia, estacionalidad y residuo.
df_decomposition = pd.DataFrame({
    'Fecha': df.index,
    'Tendencia': decomposed_spot.trend,
    'Estacionalidad': decomposed_spot.seasonal,
    'Residuo': decomposed_spot.resid
})

# Graficamos los componentes de la descomposición utilizando el estilo de la gráfica de retornos logarítmicos con outliers.
fig = px.line(df_decomposition, x='Fecha', y=['Tendencia', 'Estacionalidad', 'Residuo'], template='plotly_dark',
              color_discrete_sequence=px.colors.sequential.Greens)

# Personalizamos la gráfica.
fig.update_layout(title='<b>Descomposición Estacional del Cierre de Spotify</b>', xaxis_title='Fecha', yaxis_title='Valor', legend_title='Componentes',
                  title_x=.5)

# Mostramos la gráfica.
fig.show()

# Calculamos la media móvil de 1 sem para los datos de cierre de Spotify.
rolling_spotify = df['Close'].rolling('7D').mean()

# Creamos la figura para combinar la serie original y la media móvil.
fig = go.Figure()

# Agregamos la serie temporal original del precio de cierre de Spotify.
fig.add_trace(go.Scatter(x=df.index, y=df['Close'], mode='lines', name='Precio de Cierre', line=dict(color='lightseagreen')))

# Agregamos la media móvil de 7 días.
fig.add_trace(go.Scatter(x=df.index, y=rolling_spotify, mode='lines', name='Media Móvil 1 sem', line=dict(color='green', dash='dash')))

# Personalizamos el diseño de la gráfica.
fig.update_layout(title='<b>Precio de Cierre vs. Media Móvil 1 sem | Spotify Último Año</b>', xaxis_title='Fecha', yaxis_title='Precio de Cierre',
                  legend_title='Series', template='plotly_dark', title_x=.5)

# Mostramos la gráfica.
fig.show()

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">

<h2><b>Obtención de Retornos Logarítmicos</b></h2>
"""

# Los retornos logarítmicos permiten medir la variación porcentual continua en los precios.
# Calcular los retornos logarítmicos de los precios de cierre
log_returns = np.log(df[['Close']] / df[['Close']].shift(1)).dropna()
# Renombrar la columna para mayor claridad
log_returns = log_returns.rename(columns = {'Close' : 'Log Returns'})
log_returns.head()

# Agregamos la línea de dispersión
fig = go.Figure()

# Agregar un gráfico de línea para los retornos logarítmicos
fig.add_trace(go.Scatter(x=log_returns.index, y=log_returns['Log Returns'], mode='lines', name='Retornos Logarítmicos', line=dict(color='blue')))

# Configuración
fig.update_layout(
    title={
        'text': '<b>Retornos de Precios de Cierre de Spotify en Mercado de Valores (Oct23 - Oct24)</b>',
        'y': 0.9,
        'x': 0.5,
        'xanchor': 'center',
        'yanchor': 'top',
    },
    xaxis_title='Fecha',
    yaxis_title='Retorno (Log)',
    template='plotly_dark',
    xaxis=dict(title_font=dict(color='white'),),
    yaxis=dict(title_font=dict(color='white'),)
)

fig.show()

# Creamos la figura para visualizar la evolución los precios de cierre de acciones de Spotify
fig = go.Figure()

#  Agregamos el histograma que muestra la distribución de los retornos logarítmicos
fig.add_trace(go.Histogram(histfunc='count', x=log_returns['Log Returns'], marker_color='lightseagreen'))

# Configuración
fig.update_layout(
    title={
        'text': '<b>Histograma de Frecuencias de Retornos (Log)</b>',
        'y': 0.9,
        'x': 0.5,
        'xanchor': 'center',
        'yanchor': 'top',
    },
    xaxis_title='Retorno (Log)',
    yaxis_title='Frecuencia',
    template='plotly_dark',
    xaxis=dict(title_font=dict(color='white'),),
    yaxis=dict(title_font=dict(color='white'),)
)

fig.show()

# Revisión de la distribución normal de los retornos de Spotify

# Evaluamos la normalidad de los retornos logarítmicos (sin valores atípicos)
# Calculamos el rango intercuartil (IQR) para identificar los outliers
Q1 = log_returns['Log Returns'].quantile(0.25)
Q3 = log_returns['Log Returns'].quantile(0.75)
IQR = Q3 - Q1

# Definimos los límites inferior y superior para los outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filtramos los datos para eliminar los outliers
log_returns_no_outliers = log_returns[(log_returns['Log Returns'] >= lower_bound) & (log_returns['Log Returns'] <= upper_bound)]

# Prueba de Shapiro-Wilk para evaluar si los datos siguen una distribución normal
statistic, p_value = st.shapiro(log_returns_no_outliers['Log Returns'])

# Decisión sobre la hipótesis nula con un nivel de significancia del 5%
print(f"Shapiro-Wilk stat: {statistic}")
print(f"Shapiro-Wilk p-value: {p_value}")

alpha = 0.05
if p_value > alpha:
    print("No se rechaza H0. Los datos de precios de acciones de Spotify, sin valores atípicos, siguen una distribución normal.")
else:
    print("Se rechaza H0. Los datos de precios de acciones de Spotify, sin valores atípicos, no siguen una distribución normal.")

# Obtenemos los outliers de los retornos logarítmicos
outliers = log_returns[(log_returns['Log Returns'] < lower_bound) | (log_returns['Log Returns'] > upper_bound)]

# Gráfica de los retornos logarítmicos, resaltando los outliers
fig = px.line(log_returns, x=log_returns.index, y='Log Returns', template='plotly_dark', color_discrete_sequence=['blue'])

# Añadimos los outliers a la gráfica en forma de puntos rojos
fig.add_scatter(x=outliers.index, y=outliers['Log Returns'], mode='markers', marker=dict(color='red', size=10), name='Outliers')

# Configuración final
fig.update_layout(title='<b>Retornos Logarítmicos con Valores Atípicos</b>', xaxis_title='Fecha', yaxis_title='Retornos Logarítmicos', title_x=.5)
fig.show()

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Datos de las Tasas Libres de Riesgo (IRX)</b></h2>
"""

irx_info = yf.Ticker("^IRX")
# Periodo: Oct23 - Oct24
irx_df = irx_info.history(period="1Y")
irx_df

# Información de los datos de las tasas libres de riesgo
irx_df.info()

# Estadística descriptiva de los datos de las tasas libres de riesgo
irx_df.describe().T

# Creamos la figura para visualizar la evolución los precios de cierre de acciones de Spotify
fig = go.Figure()

# Agregamos la línea de dispersión
fig.add_trace(go.Scatter(x=irx_df.index, y=irx_df['Close'], mode='lines', name='Close Price', line=dict(color='indianred')))

fig.update_layout(
    title={
        'text': '<b>Porcentajes de Cierre de la Tasa Libre de Riesgo (Oct2023 - Oct2024)</b>',
        'y': 0.9,
        'x': 0.5,
        'xanchor': 'center',
        'yanchor': 'top',
    },
    xaxis_title='Fecha',
    yaxis_title='%',
    template='plotly_dark',
    xaxis=dict(title_font=dict(color='white'),),
    yaxis=dict(title_font=dict(color='white'),)
)

fig.show()

# Gráfico OHLC de IRX
ohlc_irx = go.Ohlc(x=irx_df.index, open=irx_df.Open, high=irx_df.High, low=irx_df.Low, close=irx_df.Close, name='IRX OHLC')
fig_irx = go.Figure(data=[ohlc_irx])
fig_irx.update_layout(
    title={
        'text': '<b>Gráfico OHLC de las Tasas Libres de Riesgo de IRX</b>',
        'x': 0.5,
        'xanchor': 'center'
    }, yaxis_title='IRX Rates',  xaxis_title='Fecha', template='plotly_dark')
fig_irx.show()

# Candlestick de IRX
candle_irx = go.Candlestick(x=irx_df.index, open=irx_df.Open, high=irx_df.High, low=irx_df.Low, close=irx_df.Close, name='IRX Candlestick')
fig_irx2 = go.Figure(data=[candle_irx])
fig_irx2.update_layout(
    title={
        'text': '<b>Gráfico de Velas de Tasas Libres de Riesgo de IRX</b>',
        'x': 0.5,
        'xanchor': 'center'
    }, yaxis_title='IRX Rates',  xaxis_title='Fecha', template='plotly_dark'
)
fig_irx2.show()

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Valores de Cierre e Intervalos de Confianza para las Tasas</b></h2>
"""

# Creación de una figura con dos gráficos tipo boxplot (subplots) para comparar Spotify e IRX.
fig = make_subplots(rows = 1, cols = 2)

# Agregamos un boxplot para los precios de cierre de Spotify (columna 'Close' del DataFrame 'df') e IRX (porcentajes de cierre).
fig.add_trace(go.Box(y = df['Close'], name = 'Spotify (Precios de Cierre)', marker_color = 'lightseagreen'), row=1, col = 1)
fig.add_trace(go.Box(y = irx_df['Close'], name = 'IRX (% de Tasas Libres de Riesgo)', marker_color = 'indianred'), row=1, col = 2)

# Configuramos el diseño del gráfico: tamaño, posición del título y estilo.
fig.update_layout(height=600, width=1000, title_x = 0.5, title_text="<b>Boxplot de los Valores de Cierre</b>", template='plotly_dark',
                 showlegend=False)

# Configura los ejes, eliminando los títulos por defecto.
fig.update_xaxes(title_text=None)
fig.update_yaxes(title_text=None)

# Añade anotaciones al gráfico: etiquetas para los ejes y título.
fig.add_annotation(x=0.5, y=-0.1,  xref='paper', yref='paper', text="<b>Organismo</b>", showarrow=False, font=dict(size=14, color="white"), xanchor='center')
fig.add_annotation(x=-0.07, y=0.5, xref='paper', yref='paper', text="<b>Valor de Cierre (Precio o %)</b>", showarrow=False,font=dict(size=14, color="white"),
                   textangle=-90, yanchor='middle')

# Añade un subtítulo descriptivo en la parte superior del gráfico.
fig.add_annotation(x=0.5, y=1.1, xref='paper', yref='paper', text='Precios de Cierre (Spotify) | Porcentajes de Cierre (IRX)', showarrow=False,
                   font=dict(size=10, color="white"))
# Añade una fuente de referencia en la parte inferior del gráfico.
fig.add_annotation(x=0.5, y=-0.11, xref="paper", yref="paper", text="Fuente: Yahoo Finance", showarrow=False, font=dict(family="Arial", size=8, color="white"),
                   xanchor='center', yanchor='top')
fig.show()

# Creación de otra figura con dos gráficos tipo boxplot para comparar los retornos logarítmicos de Spotify y las tasas de IRX.
fig = make_subplots(rows = 1, cols = 2)

# Añade un boxplot para los retornos logarítmicos de Spotify (columna 'Log Returns' del DataFrame 'log_returns') y los porcentajes de cierre (IRX)
fig.add_trace(go.Box(y = log_returns['Log Returns'], name = 'Retornos de Precios de Spotify (Log)', marker_color = 'lightseagreen'), row=1, col = 1)
fig.add_trace(go.Box(y = irx_df['Close'], name = 'IRX (% de Tasas Libres de Riesgo)', marker_color = 'indianred'), row=1, col = 2)

# Configuración del diseño del gráfico: tamaño, posición del título y estilo.
fig.update_layout(height=600, width=1000, title_x = 0.5, title_text="<b>Boxplot de los Valores de Retorno</b>", template='plotly_dark',
                 showlegend=False)

# Configuración los ejes, eliminando los títulos por defecto.
fig.update_xaxes(title_text=None)
fig.update_yaxes(title_text=None)

# Añadimos anotaciones al gráfico: etiquetas para los ejes y título.
fig.add_annotation(x=0.5, y=-0.1,  xref='paper', yref='paper', text="<b>Organismo</b>", showarrow=False, font=dict(size=14, color="white"), xanchor='center')
fig.add_annotation(x=-0.07, y=0.5, xref='paper', yref='paper', text="<b>Retorno (Log) o Tasa (%)</b>", showarrow=False,font=dict(size=14, color="white"),
                   textangle=-90, yanchor='middle')

# Añadimos un subtítulo descriptivo en la parte superior del gráfico.
fig.add_annotation(x=0.5, y=1.1, xref='paper', yref='paper', text='Valor de Retorno (Log, Spotify) | Porcentajes de Cierre (IRX)', showarrow=False,
                   font=dict(size=10, color="white"))
# Añade una fuente de referencia en la parte inferior del gráfico.
fig.add_annotation(x=0.5, y=-0.11, xref="paper", yref="paper", text="Fuente: Yahoo Finance", showarrow=False, font=dict(family="Arial", size=8, color="white"),
                   xanchor='center', yanchor='top')
fig.show()

# Cálculo del intervalo de confianza al 95% para la media de las tasas libres de riesgo (IRX).
# Se usa la distribución t de Student con un nivel de confianza del 95%.
# La media se calcula a partir de los valores de cierre de IRX, y la desviación estándar de la muestra se usa para estimar la escala.
r_low, r_high = st.t.interval(0.95, df=len(irx_df)-1, loc=irx_df['Close'].mean(), scale=st.sem(irx_df['Close']))

# Conversión a %
r_low = r_low/100
r_high = r_high/100
print(f"Tasa libre de riesgo mínima (confianza del 95%) : r = {r_low:.4f}")
print(f"Tasa libre de riesgo máxima (confianza del 95%) : r = {r_high:.4f}")

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Cadenas de Markov (2018 - 2023)</b></h2>
"""

# Se vuelven a cargar los datos de Spotify, sin embargo ahora nos interesan tener todos con el propósito de separar en entrenamiento y prueba
spot_info = yf.Ticker("SPOT")
df = spot_info.history(period="max")
adj_close = df['Close']

# Separamos los datos en entrenamiento (del 2018-2023) y prueba (2023-2024)
train_data = adj_close[:-252]
test_data = adj_close[-252:]

# Calcular el cambio porcentuak
pct_change = train_data.pct_change().dropna()

# Seleccionar los cuantiles
q_low = pct_change.quantile(0.25)
q_high = pct_change.quantile(0.75)

# Función que determina si el estado es 0 (baja), 1 (se mantiene), o 2 (sube)
def get_state(change):
    if change < q_low:
        return 0
    elif change > q_high:
        return 2
    else:
        return 1
# Calcular los estados de los datos de entrenamiento
states = pct_change.apply(get_state)

states

# Se obtiene la matriz de transición, es decir la probabilidad de que cada estado (0, 1, 2) pase a otro estado (0, 1, 2)
transition_matrix = np.zeros((3, 3))

# Llenar la matriz de transición con los estados
for i in range(1, len(states)):
    transition_matrix[states[i-1], states[i]] += 1

# Normalizar la matriz de transición para obtener probabilidades
transition_matrix = transition_matrix / transition_matrix.sum(axis=1, keepdims=True)

fig = px.imshow(transition_matrix, text_auto=".2f", color_continuous_scale="magma",
                labels=dict(x="Estado siguiente", y="Estado actual", color="Valor"),
                title="<b>Matriz de Transición - Spotify (Año Antepasado)</b>")
fig.update_layout(template="plotly_dark", width=800, height=600, title_x=0.5)
fig.show()

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b>Predicciones (2023 - 2024)</b></h2>
"""

real_pct_change = test_data.pct_change().dropna()

# Calcular los estados reales del periodo de prueba
real_states = real_pct_change.apply(get_state)

# Predicción de los estados usando la matriz de transición entrenada
last_train_state = states.iloc[-1]  # Último estado conocido en los datos de entrenamiento
predicted_states = [last_train_state]

# Simulación de predicciones para los siguientes 252 días (2023-2024)
for _ in range(len(real_states)):  # Asegurar que tenga la misma longitud que real_states
    next_state = np.random.choice([0, 1, 2], p=transition_matrix[predicted_states[-1]])
    predicted_states.append(next_state)

# Remover el primer estado inicial de las predicciones
predicted_states = predicted_states[1:]

# Verificar que ambas listas tengan la misma longitud
assert len(predicted_states) == len(real_states), "Las longitudes de los estados predichos y reales no coinciden."

# Comparar los estados reales y los estados predichos
comparison_states_df = pd.DataFrame({
    'Fecha': df.index[-len(real_states):],
    'Estado Real': real_states.values,
    'Estado Predicción': predicted_states
})

# Calcular la precisión
accuracy = (comparison_states_df['Estado Real'] == comparison_states_df['Estado Predicción']).mean()
print(f"Precisión de la predicción de estados: {accuracy * 100:.2f}%")
comparison_states_df

from inspect import walktree
import random
# Realizamos una caminata aleatoria para saber como es el comportamiento de los datos reales y los predichos
current_position_real = 0
current_position_predicted = 0

real_walk = [current_position_real]
predicted_walk = [current_position_predicted]

#Se incrementa 1 si el estado es 2, 0 si el estado es 1, y se resta 1 si el estado es 0
for real_state, predicted_state in zip(comparison_states_df['Estado Real'], comparison_states_df['Estado Predicción']):
  if real_state == 0:
    current_position_real -= 1
  elif real_state == 2:
    current_position_real += 1
  real_walk += [current_position_real]

  if predicted_state == 0:
    current_position_predicted -= 1
  elif predicted_state == 2:
    current_position_predicted += 1
  predicted_walk += [current_position_predicted]


# DataFrame con las caminatas
walk = pd.DataFrame({
    'Tiempo': list(range(len(real_walk))),
    'Caminata Real': real_walk,
    'Caminata Predicción': predicted_walk
})

# Juntamos las caminatas en un solo df para distinguirlas por tipo
walk_melted = walk.melt(id_vars=['Tiempo'], value_vars=['Caminata Real', 'Caminata Predicción'], var_name='Tipo', value_name='Posición')

# Visualización de las caminatas
fig = px.line(walk_melted, x='Tiempo', y='Posición', color='Tipo', title='<b>Comparación de Caminatas Aleatorias</b>', template='plotly_dark',
              color_discrete_sequence=['blue', 'red'])
fig.update_layout(title_x=0.5)
fig.show()

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h2><b><i>Rolling Windows</i></b></h2>
"""

# Cargar los datos de nuevo
spot_info = yf.Ticker("SPOT")
df_2 = spot_info.history(period="max")
adj_close = df_2['Close']

# Dividir en datos de entrenamiento (2018-2023) y prueba (2023-2024)
train_data = adj_close[:-252]
test_data = adj_close[-252:]

# Tamaño de la ventana deslizante
window_size = 20

# Calcular los cambios porcentuales con ventana deslizante
pct_change = train_data.pct_change().dropna().rolling(window=window_size).mean().dropna()

# Seleccionar los cuantiles para definir los estados
q_low = pct_change.quantile(0.25)
q_high = pct_change.quantile(0.75)

# Función que determina si el estado es 0 (baja), 1 (estable) o 2 (sube)
def get_state(change):
    if change < q_low:
        return 0
    elif change > q_high:
        return 2
    else:
        return 1

# Calcular los estados de entrenamiento
states = pct_change.apply(get_state)

# Crear la matriz de transicion
transition_matrix = np.zeros((3, 3))

# Llenar la matriz de transición con los estados
for i in range(1, len(states)):
    transition_matrix[states[i-1], states[i]] += 1

# Normalizar la matriz de transición para obtener probabilidades
transition_matrix = transition_matrix / transition_matrix.sum(axis=1, keepdims=True)


fig = px.imshow(transition_matrix, text_auto=".2f", color_continuous_scale="haline",
                labels=dict(x="Estado siguiente", y="Estado actual", color="Valor"),
                title="<b>Matriz de Transición - Spotify (Ventana Deslizante)</b>")
fig.update_layout(template="plotly_dark", width=800, height=600, title_x=0.5)
fig.show()

# Predicción de estados con ventana deslizante para el periodo 2023-2024

# Calcular los cambios porcentuales reales con ventana deslizante
real_pct_change = test_data.pct_change().dropna().rolling(window=window_size).mean().dropna()

# Calcular los estados reales del periodo de prueba
real_states = real_pct_change.apply(get_state)

# Predicción de los estados usando la matriz de transición entrenada
last_train_state = states.iloc[-1]  # Último estado conocido en los datos de entrenamiento
predicted_states = [last_train_state]

# Simulación de predicciones para los siguientes 252 días (2023-2024)
for _ in range(len(real_states)):  # Asegurar que tenga la misma longitud que real_states
    next_state = np.random.choice([0, 1, 2], p=transition_matrix[predicted_states[-1]])
    predicted_states.append(next_state)

# Remover el primer estado inicial de las predicciones
predicted_states = predicted_states[1:]

# Verificar que ambas listas tengan la misma longitud
assert len(predicted_states) == len(real_states), "Las longitudes de los estados predichos y reales no coinciden."

# Comparar los estados reales y los estados predichos
comparison_states_df = pd.DataFrame({
    'Fecha': df_2.index[-len(real_states):],
    'Estado Real': real_states.values,
    'Estado Predicción': predicted_states
})

# Calcular la precisión
accuracy = (comparison_states_df['Estado Real'] == comparison_states_df['Estado Predicción']).mean()
print(f"\nPrecisión de la predicción de estados con Rolling Window: {accuracy * 100:.2f}%\n")
print(comparison_states_df.head())


# Inicializamos las caminatas para los estados reales y predichos
current_position_real = 0
current_position_predicted = 0

real_walk = [current_position_real]
predicted_walk = [current_position_predicted]

# Calculamos la caminata basada en los estados
for real_state, predicted_state in zip(comparison_states_df['Estado Real'], comparison_states_df['Estado Predicción']):
    if real_state == 0:
        current_position_real -= 1
    elif real_state == 2:
        current_position_real += 1
    real_walk += [current_position_real]

    if predicted_state == 0:
        current_position_predicted -= 1
    elif predicted_state == 2:
        current_position_predicted += 1
    predicted_walk += [current_position_predicted]

# DataFrame con las caminatas
walk = pd.DataFrame({
    'Tiempo': list(range(len(real_walk))),
    'Caminata Real': real_walk,
    'Caminata Predicción': predicted_walk
})

# Juntamos las caminatas en un solo df para distinguirlas por tipo
walk_melted = walk.melt(id_vars=['Tiempo'], value_vars=['Caminata Real', 'Caminata Predicción'], var_name='Tipo', value_name='Posición')

# Visualización de las caminatas
fig = px.line(walk_melted, x='Tiempo', y='Posición', color='Tipo', title='<b>Comparación de Caminatas Aleatorias</b>', template='plotly_dark',
              color_discrete_sequence=['blue', 'red'])
fig.update_layout(title_x=0.5)
fig.show()

# Visualización de la comparación entre estados reales y predichos
fig_comp = px.scatter(comparison_states_df, x='Fecha', y=['Estado Real', 'Estado Predicción'],
                      title="<b>Comparación de Estados Reales y Predichos - Spotify</b>",
                      labels={'value': 'Estado', 'variable': 'Tipo de Estado'}, template='plotly_dark', color_discrete_sequence=['blue', 'yellow'])
fig_comp.update_layout(title_x=0.5)
fig_comp.show()

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h3><b>Insights</b></h3>
<h4>

- Precisión de la predicción de estados (30.68%): Se puede observar como el modelo tiene una precisión baja (El cual no es un porcentaje constante, pues se tratan de probabilidades, y en cada corrida la prediccion cambia), lo cual significa que las predicciones no están alineadas con los estados reales en la mayoría de los casos.

- Comparación de Caminatas Aleatorias (Año Antepasado): Observamos que hay una gran divergencia entre ambas líneas, mientras la real muestra una tendencia positiva, la predicha tiene una tendencia principalmente negativa.

- Precisión de la predicción de estados con Rolling Window (46.55%): Este método ha mejorado la precisión al 46.55%, lo cual es una mejora significativa con respecto al modelo anterior (30.68%).
Esto sugiere que la técnica de ventana deslizante ayuda a capturar mejor las tendencias en un plazo de 20 días.

- Comparación de Caminatas Aleatorias (Rolling Window): En este gráfico, las caminatas están más alineadas en comparación con la versión anterior.
Aunque siguen existiendo diferencias, la predicción sigue mejor la tendencia general de los datos reales, lo que refleja la mejora del modelo con la técnica de Rolling Window.

- Comparación de Estados Reales y Predichos: En este gráfico de dispersión, puedes observar que los estados reales y predichos a menudo coinciden en algunos momentos, pero hay bastante variabilidad, especialmente en estados de subida ("2") y estabilidad ("1").
Sin embargo, a lo largo del tiempo, parece que el modelo predice más consistentemente algunos intervalos, lo cual es una señal de mejora progresiva.

- Baja precision: La baja precison del modelo de Markov se puede deber al hecho de que las fluctuaciones en las acciones de Spotify (o cualquier empresa), no se pueden simplificar a solo el estado anterior, sino que a muchos factores políticos y sociales, los cuales no son considerados.

</h4>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">

<h3><b>Implementación del Movimiento <i>Browniano</i> Geométrico</b></h3>
"""

# Función para generar la trayectoria de un Movimiento Browniano Geométrico (GBM)
# nsteps: número de pasos, t: tiempo total, mu: tasa de retorno esperada, sigma: volatilidad, start: precio inicial
def gbm(nsteps=1000, t=1, mu=0.001, sigma=0.02, start=1):
  # Tamaño del paso del tiempo
  dt = t / nsteps
  # Cálculo los incrementos del GBM usando la ecuación (mu - 0.5*sigma^2)*dt + sigma*sqrt(dt)*ruido gaussiano
  steps = [(mu - 0.5 * sigma**2) *dt + np.random.randn()*sigma*np.sqrt(dt) for i in range(nsteps)]

  # Aplicación de la función exponencial acumulada para obtener la trayectoria del precio
  y = start * np.exp(np.cumsum(steps, axis=0))

  # Creación de la serie temporal de los tiempos correspondientes
  x = [dt*i for i in range(nsteps)]
  return x, y

df = spot_info.history(period="1Y") # Obtenemos nuevamente los datos de hace un año

# Parameter Assignments
nsteps = log_returns.shape[0] # Número de pasos igual a la longitud de los retornos logarítmicos
mu_x = log_returns.mean() # Media de los retornos logarítmicos
sigma_x = log_returns.std() # Desviación estándar de los retornos logarítmicos

h = 1 / df.shape[0] # Inverso del número de observaciones
mu = (mu_x / h) + (sigma_x**2/2*h) # Ajuste de la tasa de retorno esperada
sigma = sigma_x / np.sqrt(h) # Ajuste de la volatilidad

# Obtención de los precios de cierre reales (sin el primer valor) para usar como base en la simulación
stock_adj = df[['Close']]
prices = stock_adj['Close'][1 :].values

nsims = 10 # No. simulaciones
simulation_data = {'time': []}
simulation_data['Close'] = prices

# Ejecución de la simulación de GBM para cada iteración
for i in range(nsims):
  # Generación de la trayectoria del GBM con los parámetros definidos
  x, y = gbm(nsteps = nsteps, t=1, mu = mu, sigma = sigma, start = prices[0])
  y = y.flatten() # Trayectoria unidimensional!

  # Guardamos los tiempos y los resultados de la simulación en el diccionario
  simulation_data['time'] = x
  simulation_data['GBM {col}'.format(col = i)] = y

# Aseguramos de que la serie de precios de cierre sea unidimensional y coincida con los tiempos simulados
simulation_data['Close'] = prices[:len(simulation_data['time'])]

# Df con datos de simulación
df_sim = pd.DataFrame(simulation_data)

# Visualización de la simulación
fig = px.line(simulation_data, x = 'time', y = df_sim.columns[1:], template='plotly_dark',
              title='<b>Simulación del Comportamiento del Precio de Cierre de Acciones de Spotify (10/23 - 10/24)</b>',
              labels={'time': 'Tiempo', 'value': 'Precio de Cierre'},
              color_discrete_sequence=px.colors.sequential.haline_r, width=1200)

# Configuración de parámetros
fig.update_layout(title_x=.5, legend_title_text='Datos / Simulación')
fig.add_annotation(x=0.5, y=1.12, xref='paper', yref='paper', text='Precios de Cierre (Spotify) | Porcentajes de Cierre (IRX)', showarrow=False,
                   font=dict(size=10, color="white"))
fig.show()

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h3><b><i>Insights</i></b></h3>
<h4>
La gráfica muestra la simulación del precio de cierre de las acciones de <i>Spotify</i> entre octubre de 2023 y octubre de 2024, utilizando un modelo de Movimiento <i>Browniano</i> Geométrico (GBM) para proyectar el comportamiento futuro. Los precios simulados, representados por diferentes trayectorias de GBM (colores diversos), indican posibles escenarios de variación de los precios de las acciones, con fluctuaciones que dependen de la volatilidad y la tasa de retorno esperada. Aunque algunas trayectorias muestran un aumento significativo en el precio, otras revelan caídas, lo que subraya la incertidumbre inherente a este tipo de simulaciones en mercados financieros. La línea de color amarillo corresponde a los precios históricos de cierre, proporcionando una base comparativa entre el comportamiento real y las proyecciones futuras de los precios. En general, la simulación sugiere un rango amplio de posibles resultados para las acciones de <i>Spotify</i> en el próximo año.<br>
Al observar la simulación, podemos destacar que algunas trayectorias proyectadas por el modelo GBM muestran un crecimiento más fuerte que otras. Por ejemplo, la trayectoria marcada por la línea de color azul oscuro (GBM 9) presenta el mejor rendimiento en términos de crecimiento acumulado, superando los $450 en su punto más alto. Esta simulación podría ser interpretada como un escenario optimista, donde factores como un rendimiento financiero positivo de Spotify o una tendencia alcista en el mercado beneficiaron sus acciones.
<br>En contraste, otras trayectorias, como la GBM 4 (verde oscuro), se mantienen más planas, indicando un escenario en el que el precio de las acciones no experimenta grandes cambios o incluso disminuye a lo largo del año. Esto podría estar relacionado con eventos adversos, como noticias negativas o una corrección del mercado.
<br>Aunque es imposible predecir con certeza cuál simulación es la más precisa, el análisis sugiere que la GBM 9 podría ser la "mejor" en términos de expectativas optimistas de crecimiento. Sin embargo, los inversores deben tener en cuenta el alto nivel de incertidumbre en las predicciones del mercado, ya que estas simulaciones no pueden captar todos los posibles eventos externos o internos que puedan afectar el precio de las acciones de Spotify.<br><br>
</h4>
<h3><b>Implementación del Modelo de <i>Black-Scholes</i></b></h3>
"""

# Función para calcular el precio de una opción usando el modelo de Black-Scholes
def black_scholes(S=100, K=269.8363, T=1, r=0.01, sigma=0.001, option_type='call'):
    # Cálculo de los parámetros d1 y d2 del modelo de Black-Scholes
    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)

    # Cálculo del precio de la opción según su tipo (call o put)
    if option_type == 'call':
        option_price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    elif option_type == 'put':
        option_price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    else:
        raise ValueError("La opción europea debe ser 'call' o 'put'.")

    return option_price

# Función para calcular los precios de opciones call y put
def prices_sim(S=100, K=269.8363, T=1, r=0.01, sigma=0.001):
    # Cálculo de los precios de la opción call y put
    call_price = black_scholes(S=S, K=K, T=T, r=r, sigma=sigma, option_type='call')
    put_price = black_scholes(S=S, K=K, T=T, r=r, sigma=sigma, option_type='put')
    print(f"Call Price: {call_price:.4f}")
    print(f"Put Price: {put_price:.4f}")

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h3><b>Tasa de interés baja</b></h3>
"""

# Parámetros iniciales
S = df['Close'].iloc[-1]                                  # Precio actual de la acción
K = 300                                                   # Precio de ejercicio del contrato
T = 1                                                    # Tiempo hasta el vencimiento (aquí se normaliza a 1 año)
sigma = df['Close'].pct_change().std() * np.sqrt(len(df)) # Estimación de la volatilidad anualizada

# Cálculo inicial de los precios de la opción call y put
call_price = black_scholes(S=S, K=K, T=T, r=r_low, sigma=sigma, option_type='call')
put_price = black_scholes(S=S, K=K, T=T, r=r_low, sigma=sigma, option_type='put')

print(f"Call Price: {call_price:.4f}")
print(f"Put Price: {put_price:.4f}")

# Iteración sobre los precios de cierre para calcular los precios de las opciones en cada punto
for i in range(1, len(df)):
    S = df['Close'].iloc[i]
    c_price = black_scholes(S=S, K=K, T=T, r=r_low, sigma=sigma, option_type='call')
    p_price = black_scholes(S=S, K=K, T=T, r=r_low, sigma=sigma, option_type='put')

    # Se agregan los precios calculados al DataFrame
    df.loc[df.index[i], 'Call Price'] = c_price
    df.loc[df.index[i], 'Put Price'] = p_price

fig = px.line(df, x = df.index, y = ['Close', 'Call Price', 'Put Price'], template='plotly_dark',
              title='<b>Simulación del Comportamiento del Precio de Compra-Venta de Cierre de Acciones de Spotify (10/23 - 10/24)</b>',
              color_discrete_sequence=['lightseagreen', 'darkseagreen', 'lawngreen'], width=1200)
fig.update_layout(title_x=.5, legend_title_text='Datos / Simulación')
fig.add_annotation(x=0.5, y=1.12, xref='paper', yref='paper',
                   text=f'Metodología usada: Modelo de Black Scholes con<br>r = {r_low:.4f} | σ = {sigma:.4f} | K = {K}',
                   showarrow=False, font=dict(size=10, color="white"))
fig.show()

# Simulaciones con diferentes parámetros
print("\nAumento simulado de la volatilidad:")
r=r_low
prices_sim(S=S, K=K, T=T, r=r, sigma=sigma * 1.2)  # Aumento del 20% en la volatilidad
print("\nAumento simulado de la tasa de interés libre de riesgo:")
prices_sim(S=S, K=K, T=T, r=r * 1.2, sigma=sigma)  # Aumento del 20% en la tasa de interés
print("\nAumento simulado del precio de ejercicio:")
prices_sim(S=S, K=K * 1.2, T=T, r=r, sigma=sigma)  # Aumento del 20% en el precio de ejercicio
print("\nDisminución simulado del tiempo hasta la expiración:")
prices_sim(S=S, K=K, T=T * 0.5, r=r, sigma=sigma)  # Reducción del 50% en el tiempo hasta la expiración

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h3><b>Insights</b></h3>
<h4>
    1. <strong>Aumento simulado de la volatilidad:</strong> Un incremento del 20% en la volatilidad llevó a un aumento significativo en el precio de la opción call, que alcanzó los <strong>$110.63</strong>, mientras que la opción put se valoró en <strong>$23.07</strong>. Esta tendencia se refleja en la gráfica, donde las líneas de precios de las opciones se disparan, evidenciando que una mayor volatilidad incrementa la incertidumbre sobre los movimientos futuros del precio de la acción subyacente. Esto beneficia a ambas opciones, ya que incrementa la probabilidad de que el precio final de la acción se desplace considerablemente respecto al precio de ejercicio.
</h4>
<h4>
    2. <strong>Aumento simulado de la tasa de interés libre de riesgo:</strong> Al aumentar la tasa de interés libre de riesgo en un 20%, el precio de la opción call se redujo ligeramente a <strong>$105.33</strong>, mientras que el precio de la opción put cayó a <strong>$14.87</strong>. En la gráfica, esto se puede observar como una leve disminución en el valor de las opciones. Este comportamiento es esperado, ya que con tasas de interés más altas, el valor presente del precio de ejercicio se reduce, lo que favorece a las opciones call al aumentar la expectativa de que el precio supere el strike, y afecta negativamente a las put, disminuyendo su atractivo.
</h4>
<h4>
    3. <strong>Aumento simulado del precio de ejercicio (Strike Price):</strong> Un aumento del 20% en el precio de ejercicio provocó que el valor de la opción call cayera a <strong>$68.15</strong>, mientras que el valor de la opción put aumentó a <strong>$37.60</strong>. En la gráfica, se observa que el precio de la opción call desciende, mientras que el de la put se incrementa. Esto indica que a medida que el precio de ejercicio se eleva, se vuelve menos probable que la acción supere este precio, lo que reduce el atractivo de la opción call, mientras que las put se benefician al aumentar la probabilidad de que el precio de la acción caiga por debajo del strike.
</h4>
<h4>
    4. <strong>Disminución simulada del tiempo hasta la expiración:</strong> Al reducir el tiempo hasta la expiración en un 50%, el precio de la opción call disminuyó a <strong>$87.98</strong>, mientras que el precio de la opción put cayó drásticamente a <strong>$7.81</strong>. En la gráfica, esta reducción en el tiempo de vida de las opciones se traduce en una caída de sus valores, reflejando que a medida que se acerca la fecha de expiración, se reduce la oportunidad para que el precio de la acción se mueva significativamente. Este efecto es más pronunciado en las put, que pierden más valor, dado que su naturaleza conservadora se ve más afectada por la falta de tiempo para que ocurra un movimiento de precio favorable.
</h4>

<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h3><b>Tasa de interés alta</b></h3>
"""

# Parámetros iniciales
S = df['Close'].iloc[-1]                                  # Precio actual de la acción
K = 300                                                   # Precio de ejercicio del contrato
T = 1                                                     # Tiempo hasta la madurez (aquí se normaliza a 1 año)
sigma = df['Close'].pct_change().std() * np.sqrt(len(df)) # Estimación de la volatilidad anualizada

call_price = black_scholes(S=S, K=K, T=T, r=r_high, sigma=sigma, option_type='call')
put_price = black_scholes(S=S, K=K, T=T, r=r_high, sigma=sigma, option_type='put')

print(f"Call Price: {call_price:.4f}")
print(f"Put Price: {put_price:.4f}")

df_r_high = df.drop(['Call Price', 'Put Price'], axis=1).copy()

for i in range(1, len(df_r_high)):
  S = df_r_high['Close'].iloc[i]
  c_price = black_scholes(S=S, K=K, T=T, r=r_high, sigma=sigma, option_type='call')
  p_price = black_scholes(S=S, K=K, T=T, r=r_high, sigma=sigma, option_type='put')

  df_r_high.loc[df_r_high.index[i], 'Call Price'] = c_price
  df_r_high.loc[df_r_high.index[i], 'Put Price'] = p_price

fig = px.line(df_r_high, x = df_r_high.index, y = ['Close', 'Call Price', 'Put Price'], template='plotly_dark',
              title='<b>Simulación del Comportamiento del Precio de Compra-Venta de Cierre de Acciones de Spotify (10/23 - 10/24)</b>',
              color_discrete_sequence=['lightseagreen', 'darkseagreen', 'lawngreen'], width=1200)
fig.update_layout(title_x=.5, legend_title_text='Datos / Simulación')
fig.add_annotation(x=0.5, y=1.12, xref='paper', yref='paper',
                   text=f'Metodología usada: Modelo de Black Scholes con<br>r = {r_high:.4f} | σ = {sigma:.4f} | K = {K}',
                   showarrow=False, font=dict(size=10, color="white"))
fig.show()

print("\nAumento simulado de la volatilidad:")
r=r_high
prices_sim(S=S, K=K, T=T, r=r, sigma=sigma * 1.2)
print("\nAumento simulado de la tasa de interés libre de riesgo:")
prices_sim(S=S, K=K, T=T, r=r * 1.2, sigma=sigma)
print("\nAumento simulado del precio de ejercicio:")
prices_sim(S=S, K=K * 1.2, T=T, r=r, sigma=sigma)
print("\nDisminución simulado del tiempo hasta la expiración:")
prices_sim(S=S, K=K, T=T * 0.5, r=r, sigma=sigma)

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h3><b>Insights</b></h3>
<h4>
    1. <strong>Aumento simulado de la volatilidad:</strong> Un incremento del 20% en la volatilidad llevó a un aumento significativo en el precio de la opción call, que alcanzó <strong>$110.73</strong>, mientras que la opción put se valoró en <strong>$23.02</strong>. Esta tendencia se refleja en la gráfica, donde las líneas de precios de las opciones se disparan, evidenciando que una mayor volatilidad incrementa la incertidumbre sobre los movimientos futuros del precio de la acción subyacente. Esto beneficia a ambas opciones, ya que incrementa la probabilidad de que el precio final de la acción se desplace considerablemente respecto al precio de ejercicio.
</h4>

<h4>
    2. <strong>Aumento simulado de la tasa de interés libre de riesgo:</strong> Al aumentar la tasa de interés libre de riesgo al <strong>5.17%</strong>, el precio de la opción call se redujo ligeramente a <strong>$105.46</strong>, mientras que el precio de la opción put cayó a <strong>$14.82</strong>. En la gráfica, esto se puede observar como una leve disminución en el valor de las opciones. Este comportamiento es esperado, ya que con tasas de interés más altas, el valor presente del precio de ejercicio se reduce, lo que favorece a las opciones call al aumentar la expectativa de que el precio supere el strike, y afecta negativamente a las put, disminuyendo su atractivo.
</h4>

<h4>
    3. <strong>Aumento simulado del precio de ejercicio (Strike Price):</strong> Un aumento del 20% en el precio de ejercicio provocó que el valor de la opción call cayera a <strong>$68.24</strong>, mientras que el valor de la opción put aumentó a <strong>$37.51</strong>. En la gráfica, se observa que el precio de la opción call desciende, mientras que el de la put se incrementa. Esto indica que a medida que el precio de ejercicio se eleva, se vuelve menos probable que la acción supere este precio, lo que reduce el atractivo de la opción call, mientras que las put se benefician al aumentar la probabilidad de que el precio de la acción caiga por debajo del strike.
</h4>

<h4>
    4. <strong>Disminución simulada del tiempo hasta la expiración:</strong> Al reducir el tiempo hasta la expiración en un 50%, el precio de la opción call disminuyó a <strong>$88.04</strong>, mientras que el precio de la opción put cayó drásticamente a <strong>$7.79</strong>. En la gráfica, esta reducción en el tiempo de vida de las opciones se traduce en una caída de sus valores, reflejando que a medida que se acerca la fecha de expiración, se reduce la oportunidad para que el precio de la acción se mueva significativamente. Este efecto es más pronunciado en las put, que pierden más valor, dado que su naturaleza conservadora se ve más afectada por la falta de tiempo para que ocurra un movimiento de precio favorable.
</h4>
<br>
<h3>
<b>Simulación Monte Carlo</b>
</h3>
<h4><b>Tasa de interés baja</b></h4>
"""

# Parámetros iniciales
K = K          # Precio de ejercicio
vol = sigma        # Volatilidad
r = r_low           # Tasa libre de riesgo baja
N = 1              # No. de saltos en el tiempo
M = 1000            # No. de simulaciones

market_value = df['Close'].iloc[-1] # Precio de cierre actual
T = 1    # tiempo del contrato en años

# Solución sin bucle, más práctica
def MonteCarlo_Vectorized(S, K, T, r, vol, N, M):
  # Constantes precomputadas
  dt = T / N
  nudt = (r - 0.5*vol**2)*dt
  volsdt = vol*np.sqrt(dt)
  lnS = np.log(S)

  # Método Monte Carlo
  Z = np.random.normal(size=(N, M)) # Genera números aleatorios normales
  delta_lnSt = nudt + volsdt*Z # Cambios en el precio logarítmico
  lnSt = lnS + np.cumsum(delta_lnSt, axis=0) # Calcula el pago
  lnSt = np.concatenate( (np.full(shape=(1, M), fill_value=lnS), lnSt ) ) # Precio promedio de la acción

  # Calcula el precio de la opción
  ST = np.exp(lnSt)
  CT = np.maximum(0, ST - K)
  C0 = np.exp(-r*T)*np.sum(CT[-1])/M

  sigma = np.sqrt( np.sum( (CT[-1] - C0)**2) / (M-1) ) # Desviación estándar
  SE = sigma/np.sqrt(M) # Error estándar

  return C0, SE

df_mc = df.drop(['Call Price', 'Put Price'], axis=1).copy() # Df para agrupar datos de simulaciones Monte Carlo

for i in range(1, len(df_mc)):
  S = df_mc['Close'].iloc[i]                                  # Precio al momento de la acción
  C0, SE = MonteCarlo_Vectorized(S=S, K=K, T=T, r=r, vol=vol, N=N, M=M)       # Obtención del precio de compra de la acción (Monte Carlo) con SE
  df_mc.loc[df_mc.index[i], 'Call Price Monte Carlo'] = C0
  df_mc.loc[df_mc.index[i], 'Standard Error'] = SE

# Última simulación MC para últimos valores
C0, SE = MonteCarlo_Vectorized(S=df['Close'].iloc[-1], K=K, T=T, r=r, vol=vol, N=N, M=M)
print("Precio de compra de la opción: ${0}\nError estándar: +/- {1}".format(np.round(C0, 2), np.round(SE, 2)))

fig = px.line(df_mc, x = df_mc.index, y = ['Close', 'Call Price Monte Carlo'], template='plotly_dark',
              title='<b>Simulación del Comportamiento del Precio de Compra de Cierre de Acciones de Spotify (10/23 - 10/24)</b>',
              color_discrete_sequence=['lightseagreen', 'darkseagreen', 'lawngreen'], width=1200)
fig.update_layout(title_x=.5, legend_title_text='Datos / Simulación')
fig.add_annotation(x=0.5, y=1.12, xref='paper', yref='paper',
                   text=f'Metodología usada: Simulación Monte Carlo con<br>K = {K} | r = {r:.4f} | σ = {vol:.4f} | Simulaciones = {M}',
                   showarrow=False, font=dict(size=10, color="white"))
fig.show()

x1 = np.linspace(C0-3*SE, C0-1*SE, 100)
x2 = np.linspace(C0-1*SE, C0+1*SE, 100)
x3 = np.linspace(C0+1*SE, C0+3*SE, 100)

s1 = st.norm.pdf(x1, C0, SE)
s2 = st.norm.pdf(x2, C0, SE)
s3 = st.norm.pdf(x3, C0, SE)

# Crear un DataFrame para la visualización
data = pd.DataFrame({
    'Option Price': np.concatenate([x1, x2, x3]),
    'Probability Density': np.concatenate([s1, s2, s3]),
    'Range': ['> StDev'] * len(x1) + ['1 StDev'] * len(x2) + ['> StDev'] * len(x3)
})

# Visualización con Plotly Express
fig = px.area(data_frame=data, x='Option Price', y='Probability Density', color='Range',
    color_discrete_map={
        '> StDev': 'darkseagreen',
        '1 StDev': 'lightseagreen'
    }, title='<b>Convergence of Option Price Estimation</b>'
)

# Agregar las líneas para el valor teórico y el valor de mercado
fig.add_vline(x=C0, line_color='lawngreen', line_dash='dash', annotation_text='Valor Esperado', annotation_position="top right")
fig.add_vline(x=market_value, line_color='red', line_dash='dash', annotation_text='Valor en el Mercado', annotation_position="top left")

fig.update_layout(template='plotly_dark', title_x=0.5)

fig.show()

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h4><b>Tasa de interés alta</b></h4>
"""

df_mc = df.drop(['Call Price', 'Put Price'], axis=1).copy() # Df para agrupar datos de simulaciones Monte Carlo
r = r_high

for i in range(1, len(df_mc)):
  S = df_mc['Close'].iloc[i]                                  # Precio al momento de la acción
  C0, SE = MonteCarlo_Vectorized(S=S, K=K, T=T, r=r, vol=vol, N=N, M=M)       # Obtención del precio de compra de la acción (Monte Carlo) con SE
  df_mc.loc[df_mc.index[i], 'Call Price Monte Carlo'] = C0
  df_mc.loc[df_mc.index[i], 'Standard Error'] = SE

# Última simulación MC para últimos valores
C0, SE = MonteCarlo_Vectorized(S=df['Close'].iloc[-1], K=K, T=T, r=r, vol=vol, N=N, M=M)
print("Precio de compra de la opción: ${0}\nError estándar: +/- {1}".format(np.round(C0, 2), np.round(SE, 2)))

fig = px.line(df_mc, x = df_mc.index, y = ['Close', 'Call Price Monte Carlo'], template='plotly_dark',
              title='<b>Simulación del Comportamiento del Precio de Compra de Cierre de Acciones de Spotify (10/23 - 10/24)</b>',
              color_discrete_sequence=['lightseagreen', 'darkseagreen', 'lawngreen'], width=1200)
fig.update_layout(title_x=.5, legend_title_text='Datos / Simulación')
fig.add_annotation(x=0.5, y=1.12, xref='paper', yref='paper',
                   text=f'Metodología usada: Simulación Monte Carlo con<br>K = {K} | r = {r:.4f} | σ = {vol:.4f} | Simulaciones = {M}',
                   showarrow=False, font=dict(size=10, color="white"))
fig.show()

x1 = np.linspace(C0-3*SE, C0-1*SE, 100)
x2 = np.linspace(C0-1*SE, C0+1*SE, 100)
x3 = np.linspace(C0+1*SE, C0+3*SE, 100)

s1 = st.norm.pdf(x1, C0, SE)
s2 = st.norm.pdf(x2, C0, SE)
s3 = st.norm.pdf(x3, C0, SE)

# Crear un DataFrame para la visualización
data = pd.DataFrame({
    'Option Price': np.concatenate([x1, x2, x3]),
    'Probability Density': np.concatenate([s1, s2, s3]),
    'Range': ['> StDev'] * len(x1) + ['1 StDev'] * len(x2) + ['> StDev'] * len(x3)
})

# Visualización con Plotly Express
fig = px.area(data_frame=data, x='Option Price', y='Probability Density', color='Range',
    color_discrete_map={
        '> StDev': 'darkseagreen',
        '1 StDev': 'lightseagreen'
    }, title='<b>Convergence of Option Price Estimation</b>'
)

# Agregar las líneas para el valor teórico y el valor de mercado
fig.add_vline(x=C0, line_color='lawngreen', line_dash='dash', annotation_text='Valor Esperado', annotation_position="top right")
fig.add_vline(x=market_value, line_color='red', line_dash='dash', annotation_text='Valor en el Mercado', annotation_position="top left")

fig.update_layout(template='plotly_dark', title_x=0.5)

fig.show()

"""<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<font face = "Times New Roman" size = "3" color = "black">
<div align = "justify">
<h3><b>Insights</b></h3>
<h4>
Los resultados de las simulaciones Monte Carlo realizadas con dos diferentes tasas de interés muestran variaciones significativas en el precio estimado de la opción de compra para Spotify y el error estándar asociado. En la primera simulación, utilizando el límite inferior del intervalo de confianza para la tasa libre de riesgo, el precio de la opción resultó ser 112.44 USD, con un error estándar de ±4.54. Este resultado refleja un mayor valor de la opción cuando se considera una tasa de descuento menor, lo que hace que el valor presente de los futuros pagos sea más alto. Al utilizar la tasa superior del intervalo de confianza en la segunda simulación, el precio de la opción cayó a 105.96, con un error estándar de ±4.23, lo que indica que una mayor tasa de interés reduce el valor presente de los pagos esperados, disminuyendo así el precio de la opción.<br><br>
Estos resultados destacan la sensibilidad del precio de la opción a la tasa de interés utilizada en la simulación. Con tasas de interés más altas, el valor presente de los flujos de efectivo futuros se reduce, lo que disminuye el precio estimado de la opción. Por otro lado, la volatilidad juega un papel crucial, ya que determina la amplitud de las trayectorias simuladas del precio del activo, afectando el rango de resultados posibles y el error estándar. El algoritmo de Monte Carlo es eficaz para capturar estos factores, ya que genera múltiples trayectorias bajo la asunción del Movimiento Browniano Geométrico, proporcionando una estimación robusta del precio de la opción y permitiendo evaluar su sensibilidad frente a cambios en las variables clave.
</h4><br>

<h3><b>Resultados</b></h3>
<h4>Los resultados muestran que la aplicación del modelo de movimiento Browniano geométrico (GBM) proporcionó una estimación precisa de las trayectorias de precios de las acciones de Spotify. Este modelo, que supone que los precios siguen un proceso estocástico continuo, permitió simular múltiples escenarios posibles para la evolución futura del precio de las acciones, considerando tanto la volatilidad como una tendencia de crecimiento. Las simulaciones Monte Carlo, basadas en el GBM, fueron capaces de generar estimaciones robustas para el precio de las opciones.
Por otro lado, las cadenas de Markov con ventanas deslizantes mejoraron la precisión de las predicciones del estado de los precios a corto plazo, alcanzando una precisión del 46.55%. El modelo de Black-Scholes resultó ser efectivo para estimar los precios de opciones europeas, particularmente en períodos de baja volatilidad. En conjunto, la combinación de estos modelos permitió obtener predicciones fiables tanto para el comportamiento de los precios como para el valor de las opciones.</h4>

<h2><b>Conclusiones</b></h2>
<h3>Este estudio confirma que el uso del movimiento Browniano geométrico (GBM) en combinación con simulaciones Monte Carlo es una herramienta poderosa para modelar el comportamiento incierto de los precios de activos en mercados financieros. El GBM, al incorporar tanto el crecimiento esperado como la volatilidad de los precios, proporcionó estimaciones precisas sobre las trayectorias posibles de los precios, lo cual es crucial para el cálculo de opciones. Las simulaciones Monte Carlo, basadas en este modelo, demostraron ser especialmente útiles en escenarios de alta volatilidad.
Además, el uso de cadenas de Markov con ventanas deslizantes mejoró las predicciones a corto plazo al capturar fluctuaciones locales en los precios. Finalmente, el modelo de Black-Scholes se mostró como una metodología eficaz para la valoración de opciones europeas bajo supuestos ideales, aunque debe tenerse en cuenta que no captura bien las dinámicas de mercados más volátiles.
</h3>

<h2><b>Referencias</b></h2>
<h3>
<ol>

<li>
BBC News Mundo. (2024, septiembre 15). <i>Black</i>–<i>Scholes</i>: la fórmula creada por genios matemáticos para garantizar enormes riquezas que causó un desastre (aunque todavía se usa). BBC.com. Recuperado de <a href = "https://www.bbc.com/mundo/articles/clygyr1wzexo"><i>Black-Scholes Formula</i></a>
</li>

<li>
Boughedda, S. (2024, julio 12). <i>Spotify has upside to consensus due to higher margin verticals - Wolfe Research</i>. <i>Investing</i>.com. Recuperado de <a href = "https://www.investing.com/news/stock-market-news/spotify-has-upside-to-consensus-due-to-higher-margin-verticals--wolfe-research-432SI-3517731"><i>Spotify Higher Margin Verticals</i></a>
</li>

<li>
Carrillo. (s.f). <i>Situación Problema3: Reconocimiento de Voz.</i> Recuperado de:<a href ="https://drive.google.com/file/d/1V9WLi14NQzlh_yUwepnfFpiXOpF2LddO/view"><i>Formula Cadenas de Markov</i></a>
</li>

<li>
Chen, J. (2003, noviembre 24). <i>What are options? Types, spreads, example, and risk metrics</i>. <i>Investopedia</i>. Recuperado de <a href = "https://www.investopedia.com/terms/o/option.asp"><i>American and European Options</i></a>
</li>

<li>
Cpfund. (2018). <i>Cadenas de Markov</i>. Recuperado de <a href = "https://www.ugr.es/~bioestad/_private/cpfund10.pdf"><i>Cadenas de Markov</i></a>
</li>

<li>
¿En qué consiste la simulación de Monte Carlo? <i>Amazon</i>. Recuperado de <a href = "https://aws.amazon.com/es/what-is/monte-carlo-simulation/"><i>Simulación de Monte Carlo</i></a>
</li>

<li>
Fernando, J. (2003, noviembre 24). <i>Moving average (MA): Purpose, uses, formula, and examples</i>. <i>Investopedia</i>. Recuperado de <a href = "https://www.investopedia.com/terms/m/movingaverage.asp"><i>Moving Average</i></a>
</li>

<li>
Hayes, A. (2003, noviembre 20). <i>Black-Scholes model: What it is, how it works, and options formula</i>. <i>Investopedia</i>. Recuperado de <a href = "https://www.investopedia.com/terms/b/blackscholes.asp"><i>Black Scholes Model</i></a>
</li>

<li>
Invierte con la media móvil. Degiro.es. Recuperado de <a href = "https://www.degiro.es/estrategias/analisis-tecnico/media-movil">Media Móvil</a>
</li>

<li>
Kara, M. (2023, octubre 12). <i>Time Series, rolling windows</i>. <i>Medium</i>. Recuperado de <a href = "https://medium.com/@karamel.itu/time-series-rolling-windows-5cf9ec500e83"><i>Time Series: Rolling Windows</i></a>
</li>

<li>
López, J. F. (2017, diciembre 9). Modelo <i>Black-Scholes</i>. Economipedia. Recuperado de <a href = "https://economipedia.com/definiciones/modelo-black-scholes.html">Modelo <i>Black</i>-<i>Scholes</i></a>
</li>

<li>
<i>Monte Carlo as a tool for Financial Math</i>. (2022, enero 19). TheQuantPy. Recuperado de <a href = "https://github.com/TheQuantPy/youtube-tutorials/blob/main/2022/001%20Jan-Mar/2022-01-19%20Monte%20Carlo%20Simulation%20for%20Option%20Pricing%20with%20Python%20(Basic%20Ideas%20Explained).ipynb">GitHub</a> & <a href = "https://www.youtube.com/watch?v=pR32aii3shk&list=PLqpCwow11-OqqfELduCMcRI6wcnoM3GAZ&index=3">YouTube Video</a>
</li>

<li>
Movimiento <i>browniano</i> y proceso de <i>Lévy</i>. (s/f). Miraltabank.com. Recuperado de <a href = "https://www.miraltabank.com/movimiento-browniano-y-proceso-de-levy/?__im-PpIVWxEB=953399891213148130">Movimiento <i>browniano</i> y proceso de <i>Lévy</i></a>
</li>

<li>
<i>Option Pricing Models</i>. (s/f). <i>Corporate Finance Institute</i>. Recuperado de <a href = "https://corporatefinanceinstitute.com/resources/derivatives/option-pricing-models/"><i>Option Pricing Models</i></a>
</li>

<li>
Sánchez, C. P. (s/f). La fórmula de <i>Black & Scholes</i>. Udc.es. Recuperado de <a href = "https://oikonomicon.udc.es/la_frmula_de_black__scholes.html">La fórmula de <i>Black & Scholes</i></a>
</li>

<li>
Shadmehr, B. (2023, diciembre 6). <i>Cleaning and preprocessing financial data with pandas: A comprehensive guide</i>. <i>DEV Community</i>.  Recuperado de <a href = "https://dev.to/bshadmehr/cleaning-and-preprocessing-financial-data-with-pandas-a-comprehensive-guide-588k"><i>Cleaning and preprocessing financial data with pandas</i></a>
</li>

<li>
Teoría de Black-Scholes. (s/f). Estrategiasdeinversion.com. Recuperado de <a href = "https://www.estrategiasdeinversion.com/herramientas/diccionario/trading/teoria-de-black-scholes-t-1026"><i>Teoría de Black-Scholes</i></a>
</li>

<li>
Utilice ventanas deslizantes para gráficos más fluidos. (s/f). <i>Newrelic</i>.com. Recuperado de <a href = "https://docs.newrelic.com/es/docs/nrql/using-nrql/create-smoother-charts-sliding-windows/"><i>Sliding Windows</i></a>
</li>

</ol>
</h3>
"""

